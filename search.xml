<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2021/11/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2021/11/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h3 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>从每一个字符开始的，不包含重复字符的最长子串</li></ul><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ul><li>两个指针： 表示字符串（窗口）的左右边界，左指针代表枚举量的起始位置。</li><li>每步操作，左指针右移一格，表示<strong>枚举下个字符为起始位置</strong>，然后不断右移右指针，同时保证子串中不重复。移动结束即表示以<strong>左指针开始的最长不重复子串</strong>。</li><li>枚举结束后，ans = max（len（s1)…）。</li></ul><span id="more"></span><h5 id="判断重复字符"><a href="#判断重复字符" class="headerlink" title="判断重复字符"></a>判断重复字符</h5><p>常用数据结构为hash集合， 即<code>std::unordered_set</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; uset;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                uset.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]); <span class="comment">//遍历下一个字符开始的最大子串</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查找以s[i]开始的最大子串长度</span></span><br><span class="line">            <span class="keyword">while</span>( rk+<span class="number">1</span> &lt; n &amp;&amp; !uset.<span class="built_in">count</span>(s[rk+<span class="number">1</span>]))&#123;</span><br><span class="line">                uset.<span class="built_in">insert</span>(s[rk+<span class="number">1</span>]);</span><br><span class="line">                rk++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h1><h2 id="解法一：滑动窗口-1"><a href="#解法一：滑动窗口-1" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>​      排列不会改变字符串中字符的个数。只有两个字符串中每个字符的个数都相等时，一个字符出才是另一个字符的排列。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul><li>cnt1 统计s1中字符的个数， cnt2 统计s2中子串的字符个数</li><li>每次遍历 len（s1)长度的子串，并不断更新cnt2的字符个数</li><li>若cnt1和cnt2相等，则便是s1的排列之一是s2的子串</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用cnt[x] = cnt2 - cnt1的表示两个子串的字符之差， 如果cnt[i] == 0则表示s1的排列之一是s2的子串</li><li>使用x，y表示窗口移动时进出的字符<ul><li>x == y， 进出字符相同，对 cnt2无影响</li><li>x !=  y， 对字符x<ul><li>修改前，若cnt2[x] == cnt1[x] , 则diff +1</li><li>修改后，若cnt2[x] == cnt1[x] , 则diff -1</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>(); <span class="comment">//两个字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;  <span class="comment">//存放每个字符的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            --cnt[s1[i]-<span class="string">&#x27;a&#x27;</span>];  <span class="comment">//s1中字符出现次数记为负值</span></span><br><span class="line">            ++cnt[s2[i]-<span class="string">&#x27;a&#x27;</span>];  <span class="comment">//s2中字符出现次数记为正值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff=<span class="number">0</span>;  <span class="comment">//两个字串中不同字符的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="number">0</span>) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第n个字符开始继续遍历字符串s2</span></span><br><span class="line">        <span class="comment">//x为进入的字符， y为离开的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=s2[i]-<span class="string">&#x27;a&#x27;</span>, y = s2[i-n]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;  <span class="comment">//相同字符</span></span><br><span class="line">            <span class="keyword">if</span>(!cnt[x]) diff++;</span><br><span class="line">            cnt[x]++;  <span class="comment">//字符x次数加一</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[x] == <span class="number">0</span>) diff--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!cnt[y]) diff++;</span><br><span class="line">            cnt[y]--;  <span class="comment">//字符x次数加一</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[y] == <span class="number">0</span>) diff--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(diff == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/permutation-in-string/comments/96999">一个整洁的代码：</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排除异常的边界情况，也限定了模式串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匹配采用的窗口大小为模式串大小</span></span><br><span class="line">        <span class="keyword">int</span> windowSize = s1.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模式串的字典：可以看做一种频率分布</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">hashmap1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 动态更新的匹配窗口字典</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">hashmap2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建字典</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; windowSize; i++) &#123;</span><br><span class="line">            hashmap1[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            hashmap2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于每一轮滑窗查询，如果两个字典相等(频率分布一致)，则命中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = windowSize; i &lt; s2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 两个字典相等(频率分布一致)，则命中</span></span><br><span class="line">            <span class="keyword">if</span>(hashmap1 == hashmap2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则，向右滑窗：滑窗对于 hash 表的操作变为对应频率的增减</span></span><br><span class="line">            hashmap2[s2[i - windowSize] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            hashmap2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 整个算法采用左闭右开区间，因此最后还有一个窗口没有判断</span></span><br><span class="line">        <span class="keyword">return</span> hashmap1 == hashmap2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode, 滑动窗口， 重复字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日志</title>
      <link href="/2021/11/07/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/"/>
      <url>/2021/11/07/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1、算法入门"><a href="#1、算法入门" class="headerlink" title="1、算法入门"></a>1、算法入门</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>   [数组] [二分查找]   简单  通过率 55.3% <a href="https://leetcode-cn.com/problems/binary-search">已完成</a></p><p><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a>  [二分查找] [交互]  简单  通过率 45.3% <a href="https://leetcode-cn.com/problems/first-bad-version">已完成</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a> 简单  通过率 46.1%   <a href="https://leetcode-cn.com/problems/search-insert-position">已完成</a></p><span id="more"></span><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>  简单   <a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">已完成</a></p><p><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a>   中等    已完成](<a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a>)</p><p><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a>  简单    <a href="https://leetcode-cn.com/problems/move-zeroes">已完成</a></p><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a>  简单  <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">已完成</a></p><p><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a>   <a href="https://leetcode-cn.com/problems/reverse-string">已完成</a></p><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a>  简单  <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii">已完成</a></p><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a>  简单   <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">已完成</a></p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>  中等  <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">已完成</a></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p><a href="https://leetcode-cn.com/tag/hash-table">哈希表</a><a href="https://leetcode-cn.com/tag/string">字符串</a><a href="https://leetcode-cn.com/tag/sliding-window">滑动窗口</a> 中等   已完成</p><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>  <a href="https://leetcode-cn.com/tag/hash-table">哈希表</a><a href="https://leetcode-cn.com/tag/two-pointers">双指针</a><a href="https://leetcode-cn.com/tag/string">字符串</a><a href="https://leetcode-cn.com/tag/sliding-window">滑动窗口</a>   中等 <a href="https://leetcode-cn.com/problems/permutation-in-string">已完成</a></p><h2 id="广度优先搜索-深度优先搜索"><a href="#广度优先搜索-深度优先搜索" class="headerlink" title="广度优先搜索 / 深度优先搜索"></a>广度优先搜索 / 深度优先搜索</h2><p><a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></p><p><a href="https://leetcode-cn.com/tag/depth-first-search">深度优先搜索</a><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/matrix">矩阵</a></p><p>简单</p><p>通过率 58.1%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></p><p><a href="https://leetcode-cn.com/tag/depth-first-search">深度优先搜索</a><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/union-find">并查集</a><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/matrix">矩阵</a></p><p>中等</p><p>通过率 66.7%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></p><p><a href="https://leetcode-cn.com/tag/tree">树</a><a href="https://leetcode-cn.com/tag/depth-first-search">深度优先搜索</a><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/binary-tree">二叉树</a></p><p>简单</p><p>通过率 78.8%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p><p><a href="https://leetcode-cn.com/tag/tree">树</a><a href="https://leetcode-cn.com/tag/depth-first-search">深度优先搜索</a><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/binary-tree">二叉树</a></p><p>中等</p><p>通过率 70.5%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></p><p><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/dynamic-programming">动态规划</a><a href="https://leetcode-cn.com/tag/matrix">矩阵</a></p><p>中等</p><p>通过率 45.8%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></p><p><a href="https://leetcode-cn.com/tag/breadth-first-search">广度优先搜索</a><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/matrix">矩阵</a></p><p>中等</p><p>通过率 51.0%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p><p><a href="https://leetcode-cn.com/tag/recursion">递归</a><a href="https://leetcode-cn.com/tag/linked-list">链表</a></p><p>简单</p><p>通过率 66.7%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p><p><a href="https://leetcode-cn.com/tag/recursion">递归</a><a href="https://leetcode-cn.com/tag/linked-list">链表</a></p><p>简单</p><p>通过率 72.4%</p><p>待开启</p><h2 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归 / 回溯"></a>递归 / 回溯</h2><p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></p><p><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/backtracking">回溯</a></p><p>中等</p><p>通过率 77.0%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></p><p><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/backtracking">回溯</a></p><p>中等</p><p>通过率 78.3%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a></p><p><a href="https://leetcode-cn.com/tag/bit-manipulation">位运算</a><a href="https://leetcode-cn.com/tag/string">字符串</a><a href="https://leetcode-cn.com/tag/backtracking">回溯</a></p><p>中等</p><p>通过率 68.9%</p><p>待开启</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p><p><a href="https://leetcode-cn.com/tag/memoization">记忆化搜索</a><a href="https://leetcode-cn.com/tag/math">数学</a><a href="https://leetcode-cn.com/tag/dynamic-programming">动态规划</a></p><p>简单</p><p>通过率 53.1%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p><p><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/dynamic-programming">动态规划</a></p><p>中等</p><p>通过率 51.7%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></p><p><a href="https://leetcode-cn.com/tag/array">数组</a><a href="https://leetcode-cn.com/tag/dynamic-programming">动态规划</a></p><p>中等</p><p>通过率 68.2%</p><p>待开启</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></p><p><a href="https://leetcode-cn.com/tag/bit-manipulation">位运算</a><a href="https://leetcode-cn.com/tag/recursion">递归</a><a href="https://leetcode-cn.com/tag/math">数学</a></p><p>简单</p><p>通过率 50.5%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></p><p><a href="https://leetcode-cn.com/tag/bit-manipulation">位运算</a></p><p>简单</p><p>通过率 75.0%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></p><p><a href="https://leetcode-cn.com/tag/bit-manipulation">位运算</a><a href="https://leetcode-cn.com/tag/divide-and-conquer">分治</a></p><p>简单</p><p>通过率 70.0%</p><p>待开启</p><p><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></p><p><a href="https://leetcode-cn.com/tag/bit-manipulation">位运算</a><a href="https://leetcode-cn.com/tag/array">数组</a></p><p>简单</p><p>通过率 71.9%</p><p>待开启</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo引用本地图片无法显示的问题</title>
      <link href="/2021/11/05/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/05/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1、安装插件与配置"><a href="#1、安装插件与配置" class="headerlink" title="1、安装插件与配置"></a>1、安装插件与配置</h2><p><strong>1、安装hexo-asset-image</strong></p><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p><span id="more"></span><p>打开_config.yml文件，修改下述内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>2、创建同名文件夹</strong></p><p>在运行 <code>hexo new post :title.md</code> 来生成 <code>_posts</code> 目录的MD文档时，在 <code>/source/_posts</code> 文件夹内会建立一个与<code>:title.md文件</code>同名的文件夹，结构如下；</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文章名称(文件夹)</span><br><span class="line">├── hello.jpg</span><br><span class="line">└── test.jpg</span><br><span class="line">文章名称.md（文件）</span><br></pre></td></tr></table></figure><p>将图片保存在改文件夹中，之后就可以在远端正常显示图片了。</p><h2 id="2、Typora图片默认保存位置设置"><a href="#2、Typora图片默认保存位置设置" class="headerlink" title="2、Typora图片默认保存位置设置"></a><strong>2、Typora图片默认保存位置设置</strong></h2><p>为了图片在本地也能正常显示，修改一下图片的保存位置为</p><p><code>./$&#123;filename&#125;/</code></p><p><img src="/2021/11/05/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/image-20211106002026419.png" alt="image-20211106002026419"></p><p>这样之后图片会自动保存在同名文件夹中，在推送的时候也能正常显示了</p><h2 id="3、参考链接"><a href="#3、参考链接" class="headerlink" title="3、参考链接"></a>3、参考链接</h2><ul><li><a href="https://www.jianshu.com/p/75a8b0d9b969">https://www.jianshu.com/p/75a8b0d9b969</a></li><li><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo 本地图片 显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/05/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="11月Linux基础打卡"><a href="#11月Linux基础打卡" class="headerlink" title="11月Linux基础打卡"></a>11月Linux基础打卡</h1><h2 id="任务1：使用命令行登录指定的Linux环境"><a href="#任务1：使用命令行登录指定的Linux环境" class="headerlink" title="任务1：使用命令行登录指定的Linux环境"></a><strong>任务1：使用命令行登录指定的Linux环境</strong></h2><p><strong>任务要点：ssh登录、密码输入、环境配置</strong></p><ul><li>步骤1：配置本地登录环境</li></ul><p>因为电脑上已经有了PuTTy，所以使用该工具作为本次远程连接的工具。打开工具会进入程序主界面，如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105205327033.png" alt="image-20211105205327033"></p><span id="more"></span><ul><li><p>步骤2：使用如下信息登录系统</p></li><li><p><strong>用户名：coggle，密码：coggle，IP：139.198.15.157</strong></p></li></ul><p>我们在<strong>IP address</strong>输入栏输入IP，点击打卡按钮，进入登录页面，此时会弹出警告窗口</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105205512141.png" alt="image-20211105205512141"></p><p>点击<strong>是</strong>即可，之后进入登录页面，输入用户名和密码。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105205550109.png" alt="image-20211105205550109"></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105205709533.png" alt="image-20211105205709533"></p><p>成功进入系统页面。</p><h2 id="任务2：在目录下创建文件夹、删除文件夹"><a href="#任务2：在目录下创建文件夹、删除文件夹" class="headerlink" title="任务2：在目录下创建文件夹、删除文件夹"></a><strong>任务2：在目录下创建文件夹、删除文件夹</strong></h2><p>任务要点：创建文件夹、创建文件、删除文件、删除文件夹</p><ul><li>步骤1：学习<a href="https://www.runoob.com/linux/linux-system-contents.html">Linux的目录结构</a></li></ul><p>Linux的系统目录结构为树状结构，<img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/d0c50-linux2bfile2bsystem2bhierarchy-16361174098052.jpg" alt="img"></p><p>输入 **ls \**查看系统根目录下的文件结构，如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105210106431.png" alt="image-20211105210106431"></p><p>输入<strong>ls  /home</strong>和 <strong>ls /usr</strong>可查看home目录和usr目录下 的目录。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105210646619.png" alt="image-20211105210646619"></p><p>其中，**/etc**存放了系统配置文件，更改某些文件可能导致系统不能启动。</p><p><strong>/bin , /sbin, /usr/bin, /usr/sbin</strong> 是系统预设的执行文件所在目录，比如 ls 在 /bin/ls 目录下。</p><p><strong>/var</strong> 存放了系统程序生成的日志， 具体在 <strong>/var/log</strong>目录下。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105210951329.png" alt="image-20211105210951329"></p><ul><li><p>步骤3：</p></li><li><ul><li>在/home/coggle目录下，新建一个以你英文昵称（中间不要有空格哦）的文件夹A</li></ul><p>首先 <strong>cd /home/coggle</strong>进入目录：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105211614091.png" alt="image-20211105211614091"></p><p>之后<strong>mkdir zifei</strong>创建一个名为zifei的目录</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105211819307.png" alt="image-20211105211819307"></p><p>可以看到已经成功创建该目录。</p><ul><li>在文件夹A内部创建一个以coggle命令的文件夹B</li></ul><p>之后 <strong>cd zifei</strong>进入我们创建的目录，<strong>mkdir coggle</strong>创建 coggle文件夹</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212114111.png" alt="image-20211105212114111"></p></li><li><p>步骤4：在B文件夹内创建一个空txt文件</p></li></ul><p>之后 <strong>cd coggle</strong>进入我们创建的目录，<strong>touch empty.txt</strong>创建 一个名为empty的空txt文件，输入cat可以查看文件内容。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212258564.png" alt="image-20211105212258564"></p><ul><li>步骤5：删除步骤4创建的文件</li></ul><p>使用<strong>rm -f empty.txt</strong>命令删除该txt文件，此时可以看到当前目录下empty.txt文件已经被删除。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212421221.png" alt="image-20211105212421221"></p><ul><li>步骤6：删除文件夹B，然后删除文件夹A</li></ul><p>输入 **cd ..**进入coggle 文件夹上级目录</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212511306.png" alt="image-20211105212511306"></p><p>然后使用 <strong>rm -r coggle</strong>删除该文件夹，</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212620338.png" alt="image-20211105212620338"></p><p>同样，进入更上一级目录，删除zifei文件夹</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105212704438.png" alt="image-20211105212704438"></p><h2 id="任务3：在目录下下载文件、阅读文件"><a href="#任务3：在目录下下载文件、阅读文件" class="headerlink" title="任务3：在目录下下载文件、阅读文件"></a><strong>任务3：在目录下下载文件、阅读文件</strong></h2><p>任务要点：下载文件、移动文件、阅读文件</p><ul><li><p>步骤1：</p></li><li><ul><li>在home目录下，新建一个以你英文昵称（中间不要有空格哦）的文件夹A</li><li>在文件夹A内部创建一个以coggle命令的文件夹B</li></ul><p>同任务2，创建zifei和coggle文件夹</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105213452712.png" alt="image-20211105213452712"></p></li><li><p>步骤2：使用wget命令下载<a href="https://mirror.coggle.club/dataset/affairs.txt%EF%BC%8C%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9B">https://mirror.coggle.club/dataset/affairs.txt，到文件夹B</a></p></li><li><ul><li>wget教程：<a href="https://www.cnblogs.com/pretty-ru/p/10936023.html">https://www.cnblogs.com/pretty-ru/p/10936023.html</a></li></ul><p>使用<strong>wget <a href="https://mirror.coggle.club/dataset/affairs.txt">https://mirror.coggle.club/dataset/affairs.txt</a></strong>下载affairs.txt文件到coggle目录下</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105213640443.png" alt="image-20211105213640443"></p></li><li><p>步骤3：使用head、cat、tail命令阅读下载的文件。</p></li><li><ul><li>阅读文件基础教程：<a href="https://www.cnblogs.com/jixp/p/10833801.html">https://www.cnblogs.com/jixp/p/10833801.html</a></li></ul><p>head默认显示前10行数据，使用<strong>head  affairs.txt</strong>查看文件前10行数据</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105213949784.png" alt="image-20211105213949784"></p></li></ul><p>cat从第一行开始显示内容，输入<strong>cat  affairs.txt</strong></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105214310489.png" alt="image-20211105214310489"></p><p>tail则默认只输出最后10行数据</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105214446723.png" alt="image-20211105214446723"></p><ul><li>步骤4：在命令行使用ipython进入python3环境，并使用pandas读取下载的文件。</li></ul><p>从步骤3中的输出可以看出，数据文件使用<strong>‘，’</strong>作为分隔符。</p><ol><li>首先进入ipython，之后导入pandas库。</li></ol><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105215334999.png" alt="image-20211105215334999"></p><p>读取命令才用 <strong>read_csv</strong>或者<strong>read_table</strong>都可以。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105215540974.png" alt="image-20211105215540974"></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105215639277.png" alt="image-20211105215639277"></p><p>可以看到，该文件共有6366行，6列数据，每列分别为rate_marriage, age, yrs_married, children, religiou, affairs。</p><h2 id="任务4：在目录下使用vi或vim编辑文件"><a href="#任务4：在目录下使用vi或vim编辑文件" class="headerlink" title="任务4：在目录下使用vi或vim编辑文件"></a><strong>任务4：在目录下使用vi或vim编辑文件</strong></h2><p>任务要点：vi和vim使用</p><ul><li><p>步骤1：学习Nano的使用，<a href="https://blog.csdn.net/junxieshiguan/article/details/84104912">https://blog.csdn.net/junxieshiguan/article/details/84104912</a></p></li><li><p>步骤2：学习Vim的使用，<a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p></li><li><p>步骤3：分别使用Nano和Vim创建py文件，并输入以下内容，并运行</p></li></ul><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用nano和vim打开文件时，如果没有该文件，则会新建一个文件。</p><ol><li>首先使用<strong>nano  ex1.py</strong>创建并打开ex1.py</li></ol><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105220420766.png" alt="image-20211105220420766"></p><ul><li>​    Ctrl + G ：取得线上说明（help），比较有用 。相当于指令说明书。<br>​    Ctrl + X ：离开naon软件，如果有修改则会提示保存。<br>​    Ctrl + R ：从其他文件读入数据，可以将某个文件的内容贴在本文件中（感觉挺有意思的功能）。<br>​    Ctrl + O ：储存盘案，若你又权限的话，就能够储存盘案了。<br>​    Ctrl + C ：说明当前光标所在处的行数与列数等信息。<br>​    Ctrl + _  ： 可以直接输入行号，光标快速移动到该行。<br>​    Alt + Y ：校正语法功能，打开或者关闭，开关按钮。<br>​    Alt + M： 可以支持鼠标来移动光标的功能，开关按钮。</li></ul><p>编辑完成后，使用Ctrl+X退出，如果文件被修改，会提示是否保存文件，输入Y保存文件。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105220626660.png" alt="image-20211105220626660"></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105220722983.png" alt="image-20211105220722983"></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105220801677.png" alt="image-20211105220801677"></p><p>2、使用vim创建文件。</p><p>输入<strong>vim ex2.py</strong>创建并打开ex2.py文件，之后输入 <strong>i</strong>进入编辑模式，编辑完成后，使用ESC退出编辑模式。</p><p>使用<strong>：</strong>进入命令模式，输入wq保存并退出。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105221227368.png" alt="image-20211105221227368"></p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211105221253302.png" alt="image-20211105221253302"></p><h2 id="任务5：在目录下创建py文件，并进行运行"><a href="#任务5：在目录下创建py文件，并进行运行" class="headerlink" title="任务5：在目录下创建py文件，并进行运行"></a><strong>任务5：在目录下创建py文件，并进行运行</strong></h2><p>任务要点：python的os和sys系统接口，文件接口</p><ul><li><p>步骤1：学习python下os模块处理文件和目录的函数，<a href="https://www.runoob.com/python/os-file-methods.html">https://www.runoob.com/python/os-file-methods.html</a></p></li><li><p>步骤2：学习python下sys模块和传参函数，<a href="https://www.runoob.com/python3/python3-module.html">https://www.runoob.com/python3/python3-module.html</a></p></li><li><p>步骤3：在home/coggle目录下，在你英文昵称（中间不要有空格哦）的文件夹中，新建一个test5.py文件，该程序可以使用os、sys模块完成以下功能：</p></li></ul><h3 id="功能1：打印命令行参数"><a href="#功能1：打印命令行参数" class="headerlink" title="功能1：打印命令行参数"></a><strong>功能1：打印命令行参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令行输入：</span><br><span class="line">python3 test5.py 参数<span class="number">1</span> 参数<span class="number">2</span></span><br><span class="line"></span><br><span class="line">程序输出：</span><br><span class="line">test5.py</span><br><span class="line">参数<span class="number">1</span></span><br><span class="line">参数<span class="number">2</span></span><br></pre></td></tr></table></figure><p>1、首先进入zifei目录，创建test5.py文件</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106183411395.png" alt="image-20211106183411395"></p><p>2、使用vim编辑test5.py，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># 文件名: test5.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106183920641.png" alt="image-20211106183920641"></p><p>3、实现效果如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106184241956.png" alt="image-20211106184241956"></p><h3 id="功能2：使用os模块打印-usr-bin-路径下所有以m开头的文件。"><a href="#功能2：使用os模块打印-usr-bin-路径下所有以m开头的文件。" class="headerlink" title="功能2：使用os模块打印/usr/bin/路径下所有以m开头的文件。"></a><strong>功能2：使用os模块打印/usr/bin/路径下所有以m开头的文件。</strong></h3><p>思路：os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。使用该方法可完成本功能。</p><p>​           os.walk() 方法可以创建一个生成器，用以生成所要查找的目录及其子目录下的所有文件。</p><p>​        os.walk() 方法用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</p><p>​        os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top, topdown=Ture, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>)  </span><br><span class="line"><span class="comment"># dirpath：string，代表目录的路径；</span></span><br><span class="line"><span class="comment"># dirnames：list，包含了当前dirpath路径下所有的子目录名字（不包含目录路径）；</span></span><br><span class="line"><span class="comment"># filenames：list，包含了当前dirpath路径下所有的非目录子文件的名字（不包含目录路径）。</span></span><br></pre></td></tr></table></figure><p>1、继续编辑test5.py</p><p>2、功能代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">path = <span class="string">&quot;/usr/bin/&quot;</span></span><br><span class="line">dirs = os.listdir( path )</span><br><span class="line">key = <span class="string">&#x27;m&#x27;</span> <span class="comment">#以m开头的文件</span></span><br><span class="line">files = [i <span class="keyword">for</span> i <span class="keyword">in</span> dirs <span class="keyword">if</span> os.path.isfile(os.path.join(path,i))]</span><br><span class="line"><span class="comment"># 输出所有文件</span></span><br><span class="line"><span class="keyword">if</span> files:</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">  <span class="keyword">if</span> f[<span class="number">0</span>] == key:</span><br><span class="line">            <span class="built_in">print</span> (f)</span><br></pre></td></tr></table></figure><p>3、实现效果如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106194549232.png" alt="image-20211106194549232"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    结合任务5的功能优化，可以进一步将文件路径和文件名关键字修改为命令行参数，这样便可以打印指定目录下指定字母开头的文件了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">path = sys.argv[<span class="number">1</span>]</span><br><span class="line">dirs = os.listdir( path )</span><br><span class="line">key = sys.argv[<span class="number">2</span>]  <span class="comment">#以argv2开头的文件</span></span><br><span class="line">files = [i <span class="keyword">for</span> i <span class="keyword">in</span> dirs <span class="keyword">if</span> os.path.isfile(os.path.join(path,i))]</span><br><span class="line"><span class="comment"># 输出所有文件</span></span><br><span class="line"><span class="keyword">if</span> files:</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">  <span class="keyword">if</span> f.startswith(key):</span><br><span class="line">            <span class="built_in">print</span> (f)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106195307995.png" alt="image-20211106195307995"></p><h2 id="任务6：在目录下创建py目录，并进行import导入"><a href="#任务6：在目录下创建py目录，并进行import导入" class="headerlink" title="任务6：在目录下创建py目录，并进行import导入"></a><strong>任务6：在目录下创建py目录，并进行import导入</strong></h2><p>任务要点：python代码模块化</p><ul><li><p>步骤1：学习python模块化，<a href="https://www.runoob.com/python3/python3-module.html">https://www.runoob.com/python3/python3-module.html</a></p></li><li><p>步骤2：在/home/coggle目录下在你英文昵称（中间不要有空格哦）的文件夹中创建affairs文件夹。</p></li><li><p>步骤3：编写test6.py和affairs.py完成以下功能：</p></li><li><ul><li><h3 id="功能1：affairs-py代码完成https-mirror-coggle-club-dataset-affairs-txt文件的读取，这里可以直接pd-read-csv-39-https-mirror-coggle-club-dataset-affairs-txt-39-来完成。这一部分建议写为函数。"><a href="#功能1：affairs-py代码完成https-mirror-coggle-club-dataset-affairs-txt文件的读取，这里可以直接pd-read-csv-39-https-mirror-coggle-club-dataset-affairs-txt-39-来完成。这一部分建议写为函数。" class="headerlink" title="功能1：affairs.py代码完成https://mirror.coggle.club/dataset/affairs.txt文件的读取，这里可以直接pd.read_csv(&#39;https://mirror.coggle.club/dataset/affairs.txt&#39;)来完成。这一部分建议写为函数。"></a>功能1：affairs.py代码完成<a href="https://mirror.coggle.club/dataset/affairs.txt%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5pd.read_csv(&#39;https://mirror.coggle.club/dataset/affairs.txt&#39;)%E6%9D%A5%E5%AE%8C%E6%88%90%E3%80%82%E8%BF%99%E4%B8%80%E9%83%A8%E5%88%86%E5%BB%BA%E8%AE%AE%E5%86%99%E4%B8%BA%E5%87%BD%E6%95%B0%E3%80%82">https://mirror.coggle.club/dataset/affairs.txt文件的读取，这里可以直接pd.read_csv(&#39;https://mirror.coggle.club/dataset/affairs.txt&#39;)来完成。这一部分建议写为函数。</a></h3></li></ul><p>1、创建并进入affairs文件夹，进入并创建affairs.py文件</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106203022937.png" alt="image-20211106203022937"></p><p>2、使用vim编辑affairs.py文件</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106210331516.png" alt="image-20211106210331516"></p></li><li><ul><li><h3 id="功能2：test6-py可以导入affairs-py代码"><a href="#功能2：test6-py可以导入affairs-py代码" class="headerlink" title="功能2：test6.py可以导入affairs.py代码"></a>功能2：test6.py可以导入affairs.py代码</h3></li></ul><p>返回上级目录，创建test6.py并编辑</p><p>由于affairs.py和test6.py不在同一级目录，需要在sys的路径中添加affairs.py的路径，然后再导入该模块。</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106210116686.png" alt="image-20211106210116686"></p></li><li><ul><li><h3 id="功能3：test6-py可以进行命令行解析，输出affairs-txt具体的第几行内容。"><a href="#功能3：test6-py可以进行命令行解析，输出affairs-txt具体的第几行内容。" class="headerlink" title="功能3：test6.py可以进行命令行解析，输出affairs.txt具体的第几行内容。"></a>功能3：test6.py可以进行命令行解析，输出<a href="https://mirror.coggle.club/dataset/affairs.txt">affairs.txt</a>具体的第几行内容。</h3></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/home/coggle/</span><br><span class="line"></span><br><span class="line">    你英文昵称命名的文件夹/</span><br><span class="line"></span><br><span class="line">        test6.py</span><br><span class="line"></span><br><span class="line">        affairs/</span><br><span class="line"></span><br><span class="line">            affairs.py</span><br></pre></td></tr></table></figure><p><strong>实现要求：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在/home/coggle/你英文昵称命名的文件夹/目录下，可以执行：</span><br><span class="line"></span><br><span class="line">python3 test6.py <span class="number">10</span></span><br><span class="line"></span><br><span class="line">没有bug，并完成第十行内容的输出。</span><br></pre></td></tr></table></figure><p>继续编辑test6.py文件，完成功能3.</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106214949756.png" alt="image-20211106214949756"></p><p>命令行参数要转化为int才能作为下标索引。</p><p>效果如下：</p><p><img src="/2021/11/05/Linux%E5%9F%BA%E7%A1%80/image-20211106215044280.png" alt="image-20211106215044280"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/happymeng/p/10481293.html">https://www.cnblogs.com/happymeng/p/10481293.html</a></li><li><a href="https://blog.csdn.net/junxieshiguan/article/details/84104912">https://blog.csdn.net/junxieshiguan/article/details/84104912</a></li><li><a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></li><li><a href="https://www.runoob.com/python/os-file-methods.html">https://www.runoob.com/python/os-file-methods.html</a></li><li><a href="https://www.nhooo.com/note/qa0dwv.html">https://www.nhooo.com/note/qa0dwv.html</a></li><li><a href="https://www.cnblogs.com/yuanyongqiang/p/11714281.html">https://www.cnblogs.com/yuanyongqiang/p/11714281.html</a></li><li>读取指定行数据<a href="https://www.codeleading.com/article/58913598639/">https://www.codeleading.com/article/58913598639/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程重难点笔记"><a href="#网络编程重难点笔记" class="headerlink" title="网络编程重难点笔记"></a>网络编程重难点笔记</h1><h1 id="一：socket函数"><a href="#一：socket函数" class="headerlink" title="一：socket函数"></a>一：socket函数</h1><table><thead><tr><th>函数名称</th><th>说明</th></tr></thead><tbody><tr><td>socket</td><td>创造套接字</td></tr><tr><td>bind</td><td>将一个socket绑定到一个IP与端口的二元组上</td></tr><tr><td>listen</td><td>将一个socket变成监听状态</td></tr><tr><td>connect</td><td>尝试建立TCP连接，一般用于客户端</td></tr><tr><td>accept</td><td>尝试接收一个连接，一般用于服务的</td></tr><tr><td>send</td><td>通过一个socket发送数据</td></tr><tr><td>recv</td><td>通过一个socket接收数据</td></tr><tr><td>select</td><td>判断一组socket上的读写和异常事件</td></tr><tr><td>gethostbyname</td><td>通过域名获取机器地址</td></tr><tr><td>close</td><td>关闭一个套接字，回收该socket对应的资源。Windows中为closesocket</td></tr><tr><td>shutdown</td><td>关闭socket收发通道</td></tr><tr><td>setsockopt</td><td>设置一个套接字选项</td></tr><tr><td>getsockopt</td><td>获取一个socket选项</td></tr></tbody></table><span id="more"></span><h3 id="1、Linux中查看socket函数的帮助信息"><a href="#1、Linux中查看socket函数的帮助信息" class="headerlink" title="1、Linux中查看socket函数的帮助信息"></a>1、Linux中查看socket函数的帮助信息</h3><p><code>man + 函数签名</code>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man connect</span><br></pre></td></tr></table></figure><p><img src="/2021/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20210922093352124-16322744366551.png" alt="image-20210922093352124"></p><h3 id="2、TCP通信基本流程"><a href="#2、TCP通信基本流程" class="headerlink" title="2、TCP通信基本流程"></a>2、TCP通信基本流程</h3><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><ol><li>创建socket</li><li>bind</li><li>listen</li><li>当有请求时，accept，产生一个新的socket</li><li>基于新的socket调用send或recv，进行通信</li><li>通信结束后，close</li></ol><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol><li>创建socket</li><li>connect</li><li>send 或者 recv</li><li>close</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络， c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11</title>
      <link href="/2021/09/22/C++11/"/>
      <url>/2021/09/22/C++11/</url>
      
        <content type="html"><![CDATA[<h1 id="深入应用C-11"><a href="#深入应用C-11" class="headerlink" title="深入应用C++11"></a><a href="https://github.com/qicosmos/cosmos.git">深入应用C++11</a></h1><h2 id="一、C-11重要特性"><a href="#一、C-11重要特性" class="headerlink" title="一、C++11重要特性"></a>一、C++11重要特性</h2><h3 id="1、类型推导"><a href="#1、类型推导" class="headerlink" title="1、类型推导"></a>1、类型推导</h3><ul><li>auto</li><li>decltype</li></ul><span id="more"></span><h4 id="auto："><a href="#auto：" class="headerlink" title="auto："></a>auto：</h4><h4 id="（1）auto关键字的意义"><a href="#（1）auto关键字的意义" class="headerlink" title="（1）auto关键字的意义"></a>（1）auto关键字的意义</h4><ul><li>不同于Python等动态语言的<u><strong>运行时</strong></u>变量类型推到，隐式类型转换定义的类型在<u><strong>编译器</strong></u>推导类型。</li><li>auto类型推导是隐式类型推导</li><li>auto不是一个实际的类型声明，只是一个类型声明的“占位符”。</li><li>使用auto声明的变量必须马上初始化，以便编译器可以推断出它的类型，并在编译时将auto替换为真正的类型。</li><li>在旧标准中， “auto”代表“具有自动存储期的局部变量”。在c++11中，不再表示该含义，而是改成了一个类型指示符。</li></ul><h4 id="（2）auto的推导规则"><a href="#（2）auto的推导规则" class="headerlink" title="（2）auto的推导规则"></a>（2）auto的推导规则</h4><p>cv限定符： cv-qualifier, const和volatile限定符的统称。</p><ul><li>当不声明为指针或者引用时， auto的推导结果和初始化表达式<strong>抛弃</strong>引用和CV限定符后类型一致</li><li>当声明为指针或者引用时， auto的推到结果将保持初始化表达式的CV属性</li></ul><h4 id="（3）auto的限制"><a href="#（3）auto的限制" class="headerlink" title="（3）auto的限制"></a>（3）auto的限制</h4><ul><li>auto不能用于函数参数</li><li>不能用于**<u>非静态</u>** <u><strong>成员变量</strong></u></li><li>无法定义数组</li><li>无法推导模板参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bar&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">BAr&lt;<span class="keyword">auto</span>&gt; bb = bar;  <span class="comment">//error！</span></span><br></pre></td></tr></table></figure><h4 id="（4）auto的适用情况"><a href="#（4）auto的适用情况" class="headerlink" title="（4）auto的适用情况"></a>（4）auto的适用情况</h4><ul><li>迭代器定义 </li><li>不关心具体类型，且类型声明比较长</li><li>无法确定变量类型</li></ul><h4 id="decltype："><a href="#decltype：" class="headerlink" title="decltype："></a>decltype：</h4><h4 id="（1）获取表达式的类型"><a href="#（1）获取表达式的类型" class="headerlink" title="（1）获取表达式的类型"></a>（1）获取表达式的类型</h4><p>在**<u>编译时</u>**推导一个表达式的类型。</p><ul><li>decltype可以精确的推导出表达式定义的类型，而不会像auto在某些情况下丢弃CV限定符。</li></ul><h4 id="（2）推导规则"><a href="#（2）推导规则" class="headerlink" title="（2）推导规则"></a>（2）推导规则</h4><p>decltype（exp）</p><ul><li>exp是标识符、类访问表达式， 推导类型和exp一致</li><li>exp是函数调用， 推到类型和返回值类型一致</li><li>其他情况， 若exp是一个右值，推到类型为exp类型的左值引用，否则和exp一致</li></ul><h4 id="（3）应用"><a href="#（3）应用" class="headerlink" title="（3）应用"></a>（3）应用</h4><ul><li><p>多用于泛型编程中。 <code>decltype( container().begin() _it)</code></p></li><li><p>也常用于通过变量表达式抽取变量类型。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">decltype</span>(v)::value_type i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="返回类型后置：auto和decltype的结合"><a href="#返回类型后置：auto和decltype的结合" class="headerlink" title="返回类型后置：auto和decltype的结合"></a>返回类型后置：auto和decltype的结合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、模板细节"><a href="#2、模板细节" class="headerlink" title="2、模板细节"></a>2、模板细节</h3><h4 id="gt-gt-的二义性"><a href="#gt-gt-的二义性" class="headerlink" title="**&gt;&gt;**的二义性"></a>**&gt;&gt;**的二义性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="number">100</span> &gt;&gt; <span class="number">2</span>&gt; xx;</span><br><span class="line"></span><br><span class="line">Foo&lt;(<span class="number">100</span> &gt;&gt; <span class="number">2</span>)&gt; xx;</span><br></pre></td></tr></table></figure><h4 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h4><p>using 别名语法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h4 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h4><ul><li>函数模板参数的填充顺序是<strong>从右向左</strong></li><li>默认模板参数和模板参数自动推导同时使用时，若函数模板无法自动推导出参数类型，则使用默认模板参数</li></ul><h3 id="3、列表初始化"><a href="#3、列表初始化" class="headerlink" title="3、列表初始化"></a>3、列表初始化</h3><p><strong>聚合类型</strong></p><p><strong>std::initializer_list<T></T></strong></p><p><strong>类型收窄</strong></p><h3 id="4、基于范围的for循环"><a href="#4、基于范围的for循环" class="headerlink" title="4、基于范围的for循环"></a>4、基于范围的for循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">...</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">std::for_each(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(), <span class="built_in">do_work</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//range-based</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当range-based遍历map时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; val : map_m)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ol><li>val类型为<code>std::pair</code>。因此对于map这种<strong>关联性容器</strong>，需要使用val.first和val.second来提取键值</li><li>auto自动推导出来的类型时容器中的value_type,不是迭代器</li></ol><p>另外，要注意容器本身的一些约束：</p><ul><li>如std::set的内部元素时只读的，因此for循环中 auto &amp; 推导为 const int &amp;</li><li>range_based_for循环倾向于在循环前确定好迭代的范围，而不是在每次迭代器调用一次arr.end();</li></ul><h3 id="5、range-based-for-自定义类型"><a href="#5、range-based-for-自定义类型" class="headerlink" title="5、range_based_for + 自定义类型"></a>5、range_based_for + 自定义类型</h3><p>基于范围的for循环只是普通for的语法糖。需要查找容易的begin和end迭代器。</p><ul><li>普通array对象 —-begin为array的首地址，end为首地址+容器长度</li><li>类对象    ———-查找begin()和end()方法来定位begin和end对象</li><li>使用全局的begin和end函数来定位begin和end迭代器</li></ul><p>对于自定义对象，分别实现begin和end方法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _RANGE_HPP_#<span class="meta-keyword">define</span> _RANGE_HPP_namespace detail_range&#123;template<span class="meta-string">&lt;typename value_t&gt;</span>class RangeImpl&#123;class Iterator;public:RangeImpl(value_t begin, value_t end, value_t step = 1) :m_begin(begin), m_end(end), m_step(step)&#123;<span class="meta-keyword">if</span> (step &gt; 0 &amp;&amp; m_begin &gt;= m_end)throw std::logic_error(<span class="meta-string">&quot;end must greater than begin.&quot;</span>);<span class="meta-keyword">else</span> <span class="meta-keyword">if</span> (step <span class="meta-string">&lt; 0 &amp;&amp; m_begin &lt;= m_end)throw std::logic_error(&quot;end must less than begin.&quot;);m_step_end = (m_end - m_begin) / m_step;if (m_begin + m_step_end*m_step != m_end)&#123;m_step_end++;&#125;&#125;Iterator begin()&#123;return Iterator(0, *this);&#125;Iterator end()&#123;return Iterator(m_step_end, *this);&#125;value_t operator[](int s)&#123;return m_begin + s*m_step;&#125;int size()&#123;return m_step_end;&#125;private:value_t m_begin;value_t m_end;value_t m_step;int m_step_end;class Iterator&#123;public:Iterator(int start, RangeImpl&amp; range) : m_current_step(start), m_range(range)&#123;m_current_value = m_range.m_begin + m_current_step*m_range.m_step;&#125;value_t operator*() &#123; return m_current_value; &#125;const Iterator* operator++()&#123;m_current_value += m_range.m_step;m_current_step++;return this;&#125;bool operator==(const Iterator&amp; other)&#123;return m_current_step == other.m_current_step;&#125;bool operator!=(const Iterator&amp; other)&#123;return m_current_step != other.m_current_step;&#125;const Iterator* operator--()&#123;m_current_value -= m_range.m_step;m_current_step--;return this;&#125;private:value_t m_current_value;int m_current_step;RangeImpl&amp; m_range;&#125;;&#125;;template&lt;typename T, typename V&gt;</span>auto Range(T begin, T end, V stepsize)-&gt;RangeImpl<span class="meta-string">&lt;decltype(begin + end + stepsize)&gt;</span>&#123;return RangeImpl<span class="meta-string">&lt;decltype(begin + end + stepsize)&gt;</span>(begin, end, stepsize);&#125;template<span class="meta-string">&lt;typename T&gt;</span>RangeImpl<span class="meta-string">&lt;T&gt;</span> Range(T begin, T end)&#123;return RangeImpl<span class="meta-string">&lt;T&gt;</span>(begin, end, 1);&#125;template<span class="meta-string">&lt;typename T&gt;</span>RangeImpl<span class="meta-string">&lt;T&gt;</span> Range(T end)&#123;return RangeImpl<span class="meta-string">&lt;T&gt;</span>(T(), end, 1);&#125;&#125;#<span class="meta-keyword">endif</span>  <span class="comment">//_RANGE_HPP_</span></span></span><br></pre></td></tr></table></figure><h3 id="6、-std-function-和-bind"><a href="#6、-std-function-和-bind" class="headerlink" title="6、 std::function 和 bind"></a>6、 std::function 和 bind</h3><h4 id="6-1-可调用对象"><a href="#6-1-可调用对象" class="headerlink" title="6.1 可调用对象"></a>6.1 可调用对象</h4><ul><li>函数指针</li><li>仿函数（具有operator()方法的类)</li><li>可被转化为函数指针的类对象</li><li>类成员（函数）指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针void(* func_ptr)(void);//仿函数struct Foo&#123;    operator()    &#123;        ...    &#125;    ...&#125;;Foo foo;foo();//可被转化为函数指针的类struct Bar&#123;    using fr_t = void(*) (void);    static void func(void)    &#123;        ...    &#125;    operator fr_t(void)    &#123;        return fr_t;    &#125;&#125;;Bar bar;bar();//类成员函数指针void (A::*mem_func_ptr)(void)    = &amp;A::mem_func;//类成员指针int A::*mem_obj_ptr    = &amp;A::a_;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-std-function—–函数对象包装器"><a href="#6-2-std-function—–函数对象包装器" class="headerlink" title="6.2 std::function—–函数对象包装器"></a>6.2 std::function—–函数对象包装器</h4><ul><li>给std::function填入合适的函数签名，则变成一个可以容纳这一类调用方式的“函数包装器”</li><li>可以取代函数指针，保存函数延迟执行，适合做<strong>回调函数</strong></li></ul><h4 id="6-3-std-bind—-绑定器"><a href="#6-3-std-bind—-绑定器" class="headerlink" title="6.3 std::bind—-绑定器"></a>6.3 std::bind—-绑定器</h4><ul><li>将可调用对象与其参数一起绑定成一个仿函数</li><li>将多元可调用对象转成一元或(n-1)元可调用对象。 <strong>std::placeholders:: _1</strong>是一个占位符。</li><li>可组合多个函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="built_in">bind</span>(logical_and&lt;<span class="keyword">bool</span>&gt;(),             <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>),             <span class="built_in">bind</span>(less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));<span class="comment">//判断大于5，小于10的功能闭包</span></span><br></pre></td></tr></table></figure><h3 id="7、lambda表达式"><a href="#7、lambda表达式" class="headerlink" title="7、lambda表达式"></a>7、lambda表达式</h3><p>基本用法：</p><p><strong>[ capture ] (params) opt -&gt;ret {body};</strong></p><ul><li>[] 不捕获任何变量</li><li>[&amp;] 捕获外部作用域所有变量，并作为引用在函数体中使用</li><li>[=] 捕获外部作用域所有变量，并作为副本在函数体中使用</li><li>[=, &amp;foo] 按值捕获所有变量，按引用捕获foo</li><li>[bar] 按值捕获bar，不捕获其他变量</li><li>[this] 捕获当前类的this指针</li></ul><h3 id="8、tuple元组"><a href="#8、tuple元组" class="headerlink" title="8、tuple元组"></a>8、tuple元组</h3><hr><h2 id="二、改进C-程序性能"><a href="#二、改进C-程序性能" class="headerlink" title="二、改进C++程序性能"></a>二、改进C++程序性能</h2><h3 id="1、右值引用"><a href="#1、右值引用" class="headerlink" title="1、右值引用"></a>1、右值引用</h3><h3 id="2、move语义"><a href="#2、move语义" class="headerlink" title="2、move语义"></a>2、move语义</h3><h3 id="3、forward和完美转发"><a href="#3、forward和完美转发" class="headerlink" title="3、forward和完美转发"></a>3、forward和完美转发</h3><h3 id="4、emplace-back"><a href="#4、emplace-back" class="headerlink" title="4、emplace_back"></a>4、emplace_back</h3><h3 id="5、无序容器"><a href="#5、无序容器" class="headerlink" title="5、无序容器"></a>5、无序容器</h3><h2 id="三、提高C-代码质量"><a href="#三、提高C-代码质量" class="headerlink" title="三、提高C++代码质量"></a>三、提高C++代码质量</h2><h3 id="1、type-traits—-类型萃取"><a href="#1、type-traits—-类型萃取" class="headerlink" title="1、type_traits—-类型萃取"></a>1、type_traits—-类型萃取</h3><h3 id="2、可变参数模板"><a href="#2、可变参数模板" class="headerlink" title="2、可变参数模板"></a>2、可变参数模板</h3><h3 id="3、综合应用"><a href="#3、综合应用" class="headerlink" title="3、综合应用"></a>3、综合应用</h3><h2 id="四、解决内存C-内存泄露问题"><a href="#四、解决内存C-内存泄露问题" class="headerlink" title="四、解决内存C++内存泄露问题"></a>四、解决内存C++内存泄露问题</h2><h3 id="1、shared-ptr"><a href="#1、shared-ptr" class="headerlink" title="1、shared_ptr"></a>1、shared_ptr</h3><h3 id="2、unique-ptr"><a href="#2、unique-ptr" class="headerlink" title="2、unique_ptr"></a>2、unique_ptr</h3><h3 id="3、weak-ptr"><a href="#3、weak-ptr" class="headerlink" title="3、weak_ptr"></a>3、weak_ptr</h3><h3 id="4、第三方库内存管理"><a href="#4、第三方库内存管理" class="headerlink" title="4、第三方库内存管理"></a>4、第三方库内存管理</h3><h2 id="五、多线程开发"><a href="#五、多线程开发" class="headerlink" title="五、多线程开发"></a>五、多线程开发</h2><h3 id="1、线程"><a href="#1、线程" class="headerlink" title="1、线程"></a>1、线程</h3><h3 id="2、互斥量"><a href="#2、互斥量" class="headerlink" title="2、互斥量"></a>2、互斥量</h3><h3 id="3、条件变量"><a href="#3、条件变量" class="headerlink" title="3、条件变量"></a>3、条件变量</h3><h3 id="4、原子变量"><a href="#4、原子变量" class="headerlink" title="4、原子变量"></a>4、原子变量</h3><h3 id="5、call-once、once-flag"><a href="#5、call-once、once-flag" class="headerlink" title="5、call_once、once_flag"></a>5、call_once、once_flag</h3><h3 id="6、异步操作"><a href="#6、异步操作" class="headerlink" title="6、异步操作"></a>6、异步操作</h3><h3 id="7、线程异步操作函数"><a href="#7、线程异步操作函数" class="headerlink" title="7、线程异步操作函数"></a>7、线程异步操作函数</h3><h2 id="六、便利的工具"><a href="#六、便利的工具" class="headerlink" title="六、便利的工具"></a>六、便利的工具</h2><h3 id="1、chrono库"><a href="#1、chrono库" class="headerlink" title="1、chrono库"></a>1、chrono库</h3><h3 id="2、类型转换"><a href="#2、类型转换" class="headerlink" title="2、类型转换"></a>2、类型转换</h3><h3 id="3、宽窄字符转换"><a href="#3、宽窄字符转换" class="headerlink" title="3、宽窄字符转换"></a>3、宽窄字符转换</h3><h2 id="七、其他特性"><a href="#七、其他特性" class="headerlink" title="七、其他特性"></a>七、其他特性</h2><h3 id="1、委托构造函数和继承构造函数"><a href="#1、委托构造函数和继承构造函数" class="headerlink" title="1、委托构造函数和继承构造函数"></a>1、委托构造函数和继承构造函数</h3><h3 id="2、原始字面量"><a href="#2、原始字面量" class="headerlink" title="2、原始字面量"></a>2、原始字面量</h3><h3 id="3、final和override关键字"><a href="#3、final和override关键字" class="headerlink" title="3、final和override关键字"></a>3、final和override关键字</h3><h3 id="4、内存对齐"><a href="#4、内存对齐" class="headerlink" title="4、内存对齐"></a>4、内存对齐</h3>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++项目列表</title>
      <link href="/2021/09/22/c++projects/"/>
      <url>/2021/09/22/c++projects/</url>
      
        <content type="html"><![CDATA[<h1 id="C-项目"><a href="#C-项目" class="headerlink" title="C++项目"></a>C++项目</h1><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><ul><li>文字<ul><li><a href="http://www.buildyourownlisp.com/">Build Your Own Lisp</a></li><li><a href="https://viewsourcecode.org/snaptoken/kilo/">Build Your Own Text Editor</a></li><li><a href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/">Concurrent Servers</a></li><li><a href="http://digitalsoundandmusic.com/chapters/ch5/5-3/">Digital sound and music</a></li></ul><span id="more"></span><ul><li><a href="https://arjunsreedharan.org/post/82710718100/kernels-101-lets-write-a-kernel">Kernels 101 – Let’s write a Kernel</a></li><li><a href="https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp">Let’s code a TCP/IP stack</a></li><li><a href="https://github.com/tuhdo/os01">Operating Systems: From 0 to 1</a></li><li><a href="https://norasandler.com/2017/11/29/Write-a-Compiler.html">Writing a C Compiler</a></li><li><a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/">Writing a Linux Debugger</a></li><li><a href="http://users.cs.cf.ac.uk/Dave.Marshall/C/node33.html#SECTION003310000000000000000">Write a RPC framework</a></li><li><a href="https://segmentfault.com/a/1190000007408126">实现一个简单的编译器</a></li><li><a href="https://www.shiyanlou.com/courses/1105">用 C 编写打字练习软件</a></li><li><a href="https://www.shiyanlou.com/courses/670">用 C 语言编写自己的编程语言</a></li><li><a href="https://www.shiyanlou.com/courses/231">缓冲区溢出漏洞实验</a></li></ul></li><li>视频<ul><li><a href="https://www.udemy.com/course/learn-c-game-development/">Learn C++ Game Development</a></li><li><a href="https://www.shiyanlou.com/courses/1218">C++ 解决迷宫问题</a></li><li><a href="https://www.shiyanlou.com/courses/1182">C++ 使用 openGL 实现吃豆人游戏</a></li><li><a href="https://www.bilibili.com/video/av62785783">C++ 项目实战</a></li><li><a href="https://www.bilibili.com/video/av7126182">牛 B 闪闪坦克大战</a></li><li><a href="https://www.bilibili.com/video/av67260826">微信飞机大战</a></li><li><a href="https://www.bilibili.com/video/av65016216">小游戏完整项目制作</a></li></ul></li></ul><h3 id><a href="#" class="headerlink" title></a></h3><h1 id="C-中基于项目的教程"><a href="#C-中基于项目的教程" class="headerlink" title="C 中基于项目的教程"></a>C 中基于项目的教程</h1><p>致力于用 C 制作小型到大型项目的教程列表。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://github.com/rby90/project-based-tutorials-in-c#computer-architecture">计算机架构</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#computer-networking">计算机网络</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#databases">数据库</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#game-development">游戏开发</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#operating-systems">操作系统</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#programming-languages">编程语言</a></li><li><a href="https://github.com/rby90/project-based-tutorials-in-c#uncategorized">未分类</a></li></ul><h2 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h2><ul><li><p><a href="https://github.com/pervognsen/bitwise">按位</a> <code>video</code> <code>abandoned</code></p></li><li><p><a href="http://emulator101.com/">模拟器 101</a></p></li><li><p><a href="https://felixangell.com/blogs/virtual-machine-in-c">用 C 实现虚拟机</a></p></li><li><p>编写芯片 8 仿真器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in-progress</span><br></pre></td></tr></table></figure><ul><li><a href="http://craigthomas.ca/blog/2014/06/21/writing-a-chip-8-emulator-part-1/">第1部分</a></li><li><a href="http://craigthomas.ca/blog/2014/07/17/writing-a-chip-8-emulator-part-2/">第2部分</a></li><li><a href="http://craigthomas.ca/blog/2015/02/19/writing-a-chip-8-emulator-draw-command-part-3/">第 3 部分</a></li><li><a href="http://craigthomas.ca/blog/2017/10/15/writing-a-chip-8-emulator-built-in-font-set-part-4/">第 4 部分</a></li><li><a href="http://craigthomas.ca/blog/2018/09/07/writing-a-chip-8-emulator-instruction-set-part-5/">第 5 部分</a></li></ul></li><li><p><a href="https://cturt.github.io/cinoop.html">编写 Game Boy 模拟器</a></p></li><li><p><a href="https://justinmeiners.github.io/lc3-vm/">编写自己的虚拟机</a></p></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li><a href="http://beej.us/guide/bgnet/html/multi/index.html">Beej 的网络编程指南</a> <code>book</code></li><li><a href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/">并发服务器</a></li><li><a href="https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa">HTTP 服务器：从头开始构建一个简单的 HTTP 服务器需要知道的一切</a></li><li>让我们编写一个 TCP/IP 堆栈<ul><li><a href="http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/">第 1 部分：以太网和 ARP</a></li><li><a href="http://www.saminiir.com/lets-code-tcp-ip-stack-2-ipv4-icmpv4/">第 2 部分：IPv4 和 ICMPv4</a></li><li><a href="http://www.saminiir.com/lets-code-tcp-ip-stack-3-tcp-handshake/">第 3 部分：TCP 基础知识和握手</a></li><li><a href="http://www.saminiir.com/lets-code-tcp-ip-stack-4-tcp-data-flow-socket-api/">第 4 部分：TCP 数据流和套接字 API</a></li><li><a href="http://www.saminiir.com/lets-code-tcp-ip-stack-5-tcp-retransmission/">第 5 部分：TCP 重传</a></li></ul></li><li><a href="https://lettier.github.io/posts/2016-04-26-lets-make-a-ntp-client-in-c.html">让我们用 C 语言创建一个 NTP 客户端</a></li><li>从头开始编写 MQTT 代理<ul><li><a href="https://codepr.github.io/posts/sol-mqtt-broker">第 1 部分 - 协议</a></li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p2">第 2 部分 - 网络</a></li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p3">第 3 部分 - 服务器</a></li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p4">第 4 部分 - 数据结构</a></li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p5">第 5 部分 - 主题抽象</a></li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p6">第 6 部分 - 处理程序</a></li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="https://cstack.github.io/db_tutorial/">让我们建立一个简单的数据库</a></li></ul><h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><ul><li><p><a href="https://gtk.dashgl.com/?folder=Astroids">小行星克隆</a></p></li><li><p><a href="https://gtk.dashgl.com/?folder=Brickout">分块克隆</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLZ1QII7yudbc-Ky058TEaOstZHVbT-2hg">C中的国际象棋引擎</a> <code>video</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLkTXsX7igf8edTYU92nU-f5Ntzuf-RKvW">用 C 编写数独求解器</a> <code>video</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLkTXsX7igf8erbWGYT4iSAhpnJLJ0Nk5G">用 C 编写 Rogue/Nethack RPG</a> <code>video</code></p></li><li><p><a href="https://www.udemy.com/course/game-loop-c-sdl/">使用 C 和 SDL 创建游戏循环</a> <code>course</code></p></li><li><p><a href="https://www.parallelrealities.co.uk/tutorials/#ppp">创建 2D 平台游戏</a></p></li><li><p><a href="https://www.parallelrealities.co.uk/tutorials/#shooter">创建一个 2D 射击游戏</a></p></li><li><p><a href="https://www.parallelrealities.co.uk/tutorials/#bad">创建一个 2D 自上而下的射击游戏</a></p></li><li><p><a href="https://handmadehero.org/">手工英雄</a> <code>video</code> <code>in-progress</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLZ1QII7yudbd2ZHYSEWrSddsvD5PW_r5O">刽子手</a> <code>video</code></p></li><li><p><a href="https://nesdoug.com/">如何用 C 编写 NES 游戏</a></p></li><li><p><a href="https://helderman.github.io/htpataic/htpataic01.html">如何用 C 编写文本冒险</a> <code>in-progress</code></p></li><li><p><a href="https://jborza.github.io/games/2020/07/12/solitaire-cli.html">用 C 语言实现纸牌</a></p></li><li><p><a href="https://gtk.dashgl.com/?folder=Invaders">入侵者克隆</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLeEj4c2zF7PaFv5MPYhNAkBGrkx4iPGJo">学习如何开发自己的 GameBoy 游戏</a> <code>video</code> <code>in-progress</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLT6WFYYZE6uLMcPGS3qfpYm7T_gViYMMt">用 C 学习视频游戏编程</a> <code>video</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLSkJey49cOgTSj465v2KbLZ7LMn10bCF9">让我们做：危险的戴夫</a> <code>video</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL7Ej6SUky1357r-Lqf_nogZWHssXP-hvH">从头开始用 C 语言制作游戏</a> <code>video</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLlaINRtydtNWuRfd4Ra3KeD6L9FP_tDE7">用 C 从头开始制作视频游戏</a> <code>video</code> <code>in-progress</code></p></li><li><p><a href="https://brennan.io/2015/06/12/tetris-reimplementation/">关于俄罗斯方块和重新实现</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL6Ikt4l3NbVjb7WR-eTgjOBMNCn7f3u7x">SDL 2 等距游戏教程</a> <code>video</code> <code>in-progress</code></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLZ1QII7yudbc7_ZgXA-gIXmME41Rs2GP5">C 中的简单井字游戏</a> <code>video</code></p></li><li><p>文字冒险 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in-progress</span><br></pre></td></tr></table></figure><ul><li><a href="https://youtu.be/J_Igbh0RH8c">第1集</a></li><li><a href="https://www.youtube.com/watch?v=7dYKhiruW1M">第 2 集</a></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=gCVMkKgs3uQ">使用 SDL 用 C 语言编写的井字游戏</a> <code>video</code></p></li><li><p>电子游戏物理教程</p><ul><li><a href="https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics">第一部分：刚体动力学简介</a></li><li><a href="https://www.toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects">第二部分：固体物体的碰撞检测</a></li><li><a href="https://www.toptal.com/game/video-game-physics-part-iii-constrained-rigid-body-simulation">第三部分：约束刚体仿真</a></li></ul></li><li><p><a href="https://www.hanshq.net/othello.html">用 C 从头开始编写黑白棋游戏</a></p></li><li><p><a href="https://www.hanshq.net/fire.html">用汇编和 C 编写老派火效应和裸机编程</a></p></li><li><p><a href="https://www.youtube.com/watch?v=yFLa3ln16w0">使用 SDL 用 C 语言编写 2D 游戏</a> <code>video</code></p></li><li><p><a href="https://www.reinterpretcast.com/writing-a-game-boy-advance-game">编写 Game Boy Advance 游戏</a></p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><p><a href="https://github.com/jserv/mini-arm-os">从头开始为 ARM 构建一个最小的多任务操作系统内核</a></p></li><li><p><a href="https://github.com/tokenrove/build-your-own-shell">构建你自己的外壳</a></p></li><li><p><a href="https://jsandler18.github.io/">为 Raspberry Pi 构建操作系统</a></p></li><li><p><a href="https://blog.holbertonschool.com/hack-virtual-memory-stack-registers-assembly-code/">破解虚拟内存</a></p></li><li><p><a href="https://github.com/cfenollosa/os-tutorial">如何从头开始创建操作系统</a> <code>in-progress</code></p></li><li><p><a href="https://david942j.blogspot.com/2018/10/note-learning-kvm-implement-your-own.html">学习 KVM - 实现你自己的内核</a></p></li><li><p><a href="https://github.com/s-matyukevich/raspberry-pi-os">使用Linux内核和树莓派学习操作系统开发</a> <code>in-progress</code></p></li><li><p><a href="https://github.com/kamalmarhubi/shell-workshop">让我们构建一个shell！</a></p></li><li><p><a href="https://danluu.com/malloc-tutorial/">让我们写一个 Malloc</a></p></li><li><p>让我们写一个内核</p><ul><li><a href="https://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel">第 1 部分 - 内核 101</a></li><li><a href="https://arjunsreedharan.org/post/99370248137/kernel-201-lets-write-a-kernel-with-keyboard">第 2 部分 - 内核 201</a></li></ul></li><li><p><a href="https://blog.lizzie.io/linux-containers-in-500-loc.html">500 行代码的 Linux 容器</a></p></li><li><p><a href="https://medium.com/@lduck11007/operating-systems-development-for-dummies-3d4d786e8ac">Dummies的操作系统开发</a></p></li><li><p><a href="https://tuhdo.github.io/os01/">操作系统：从 0 到 1</a> <code>book</code></p></li><li><p><a href="https://www.ops-class.org/">OS161：了解操作系统所需的一切</a> <code>course</code></p></li><li><p>重写 BSD 4.4 Shell 命令： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.youtube.com/watch?v=MCuzvy79WWQ">猫</a></li><li><a href="https://www.youtube.com/watch?v=p7uJBl4A_BA">修改</a></li><li><a href="https://www.youtube.com/watch?v=69CYF7nJKj8">回声</a></li><li><a href="https://www.youtube.com/watch?v=t96qYd4OUBM">目录</a></li></ul></li><li><p><a href="http://www.jamesmolloy.co.uk/tutorial_html/">推出您自己的玩具 UNIX 克隆操作系统</a></p></li><li><p><a href="https://littleosbook.github.io/">关于操作系统开发的小书</a> <code>book</code></p></li><li><p><a href="https://brennan.io/2015/01/16/write-a-shell-in-c/">用 C 写一个 Shell</a></p></li><li><p><a href="https://arjunsreedharan.org/post/148675821737/write-a-simple-memory-allocator">编写一个简单的内存分配器</a></p></li><li><p><a href="https://brennan.io/2016/11/14/kernel-dev-ep3/">编写系统调用</a></p></li><li><p><a href="https://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/">编写 FUSE 文件系统</a></p></li><li><p><a href="https://danishprakash.github.io/2018/01/15/write-a-shell.html">用 C 写一个 shell</a></p></li><li><p>编写 Unix Shell</p><ul><li><a href="https://indradhanush.github.io/blog/writing-a-unix-shell-part-1">第1部分</a></li><li><a href="https://indradhanush.github.io/blog/writing-a-unix-shell-part-2">第2部分</a></li><li><a href="https://indradhanush.github.io/blog/writing-a-unix-shell-part-3">第 3 部分</a></li></ul></li></ul><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><ul><li><a href="https://github.com/DoctorWkt/acwj">编译器写作之旅</a></li><li><a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html">正则表达式匹配器</a></li><li><a href="https://swtch.com/~rsc/regexp/regexp1.html">正则表达式匹配既简单又快速</a></li><li><a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">宝宝的第一个垃圾收集器</a></li><li><a href="http://www.buildyourownlisp.com/">构建你自己的 Lisp</a> <code>book</code></li><li><a href="https://holub.com/goodies/compiler/compilerDesignInC.pdf">C 编译器设计</a> <code>book</code></li><li><a href="http://www.craftinginterpreters.com/">制作口译员</a> <code>book</code> <em>第 14-30 章</em></li><li><a href="https://github.com/lotabout/Let-s-build-a-compiler">让我们构建一个编译器：AC &amp; x86 版本</a></li><li>编写 C 解释器<ul><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/0-Preface.md">第 0 部分 - 前言</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/1-Skeleton.md">第 1 部分 - 骨架</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/2-Virtual-Machine.md">第 2 部分 - 虚拟机</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/3-Lexer.md">第 3 部分 - 词法分析器</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/4-Top-down-Parsing.md">第 4 部分 - 自顶向下的解析</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/5-Variables.md">第 5 部分 - 变量</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/6-Functions.md">第 6 部分 - 函数</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/7-Statements.md">第 7 部分 - 声明</a></li><li><a href="https://github.com/lotabout/write-a-C-interpreter/blob/master/tutorial/en/8-Expressions.md">第 8 部分 - 表达式</a></li></ul></li><li><a href="http://maplant.com/gc.html">用 C 编写一个简单的垃圾收集器</a></li><li>从头开始的计划<ul><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-introduction">第 1 部分 - 介绍</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_1-integers">第 2 部分 - 整数</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_2-booleans">第 3 部分 - 布尔值</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_3-characters">第 4 部分 - 字符</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_4-strings">第 5 部分 - 字符串</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_5-the-empty-list">第 6 部分 - 空列表</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_6-pairs">第 7 部分 - 对</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_7-symbols">第 8 部分 - 符号</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_8-quote">第 9 部分 - 报价</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_9-environments">第 10 部分 - 环境</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_10-if">第 11 部分 - 如果</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_11-primitive-procedures-part-1">第 12 部分 - 原始程序第 1 部分</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_12-primitive-procedures-part-2">第 13 部分 - 原始程序第 2 部分</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_13-lambda-the-ultimate">第 14 部分 - 终极版 Lambda</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_14-begin">第 15 部分 - 开始</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_15-cond">第 16 部分 - 条件</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_16-let">第 17 部分 - 让</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_17-and-and-or">第 18 部分 - 和和或</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_18-apply">第 19 部分 - 申请</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_19-eval">第 20 部分 - 评估</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_20-io">第 21 部分 - I/O</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_21-standard-library">第 22 部分 - 标准库</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-v0_22-garbage-collection">第 23 部分 - 垃圾收集</a></li><li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-bootstrap-conclusion">第 24 部分 - 结论</a></li></ul></li></ul><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><ul><li>C 语言中的虚拟区块链实现<ul><li><a href="https://myram.xyz/c-blockchain-implementation-1/">第1部分</a></li><li><a href="https://myram.xyz/c-blockchain-implementation-2/">第2部分</a></li></ul></li><li><a href="https://viewsourcecode.org/snaptoken/kilo/">构建您自己的文本编辑器</a></li><li><a href="http://dranger.com/ffmpeg/ffmpeg.html">如何编写少于 1000 行的视频播放器</a></li><li><a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial">艰难地学习 FFmpeg libav</a> <code>in-progress</code></li><li><a href="https://github.com/jamesroutley/write-a-hash-table">用C写一个哈希表</a></li><li><a href="https://www.hanshq.net/bigint.html">用 C 编写 BigInt 计算器</a></li><li><a href="https://www.hanshq.net/zip.html">用 C 从头开始编写你自己的 Zip</a></li><li><a href="http://www.codedrome.com/svg-library-in-c/">编写 SVG 库</a></li></ul><h3 id="Tinyhttpd"><a href="#Tinyhttpd" class="headerlink" title="Tinyhttpd"></a>Tinyhttpd</h3><p>介绍：tinyhttpd 是一个不到 500 行的超轻量型 Http Server，非常适合学习服务器工作原理</p><p>源码分析：<a href="http://blog.csdn.net/programvae/article/details/71036295">在此</a></p><p>链接：<a href="https://github.com/yangtingcheng/tinyhttpd">tinyhttpd</a></p><h3 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a>MemoryPool</h3><p>介绍：一个用 C++ 实现的简单内存池</p><p>源码分析：<a href="http://blog.csdn.net/jcjc918/article/details/44997089">在此</a></p><p>链接：<a href="https://github.com/AngryHacker/code-with-comments/tree/master/memorypool/C-98">MemoryPool(98 版本)</a></p><h3 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a>Webbench</h3><p>介绍：Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL， 测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。</p><p>源码分析：<a href="http://blog.csdn.net/jcjc918/article/details/44965951">在此</a></p><p>链接：<a href="https://github.com/AngryHacker/code-with-comments/tree/master/webbench">webbench</a></p><h3 id="Threadpool"><a href="#Threadpool" class="headerlink" title="Threadpool"></a>Threadpool</h3><p>介绍：基于 pthread 实现的简单线程池</p><p>源码分析：<a href="http://blog.csdn.net/jcjc918/article/details/50395528">在此</a></p><p>链接：<a href="https://github.com/AngryHacker/code-with-comments/tree/master/threadpool">Threadpool</a></p><h3 id="Leveldb"><a href="#Leveldb" class="headerlink" title="Leveldb"></a>Leveldb</h3><p>介绍：Jeff Dean 和 Sanjay Ghemawat 两位超级大神实现的高效 kv 数据库。</p><p>源码分析：</p><ul><li><a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">LevelDb 日知录</a></li><li><a href="https://github.com/AngryHacker/code-with-comments/blob/master/attachment/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">leveldb 实现解析 - 那岩</a></li></ul><p>以上是我觉得分析得最好的两篇。不过随着 leveldb 项目的推进，有些代码也发生了变动。我进行注释的源码是最新的 1.18 版本，结合两篇解析写自己的理解，目前已阅读的是主要流程，水平有限，有些地方也不甚清楚，欢迎交流。</p><p>链接：<a href="https://github.com/AngryHacker/code-with-comments/tree/master/leveldb">Leveldb</a></p><h2 id="第8086章-贪吃蛇"><a href="#第8086章-贪吃蛇" class="headerlink" title="第8086章 贪吃蛇"></a>第8086章 贪吃蛇</h2><p>时间：2016-12</p><p>介绍：<a href="https://blog.csdn.net/to_be_better/article/details/53512913">https://blog.csdn.net/to_be_better/article/details/53512913</a></p><p><a href="https://github.com/shiyicode/project/blob/master/readme-images/20161208122620511.gif"><img src="https://github.com/shiyicode/project/raw/master/readme-images/20161208122620511.gif" alt="img"></a></p><h2 id="步步为营-墙棋AI人机对战-Android"><a href="#步步为营-墙棋AI人机对战-Android" class="headerlink" title="步步为营-墙棋AI人机对战(Android)"></a>步步为营-墙棋AI人机对战(Android)</h2><p>时间：2016-08</p><p>介绍：<a href="https://shiyi.blog.csdn.net/article/details/52088396">https://shiyi.blog.csdn.net/article/details/52088396</a></p><p><a href="https://github.com/shiyicode/project/blob/master/readme-images/20160801191336969.png"><img src="https://github.com/shiyicode/project/raw/master/readme-images/20160801191336969.png" alt="img"></a></p><h2 id="C-QT-俄罗斯对话框"><a href="#C-QT-俄罗斯对话框" class="headerlink" title="C++/QT 俄罗斯对话框"></a>C++/QT 俄罗斯对话框</h2><p>时间：2016-04</p><p>介绍：<a href="https://shiyi.blog.csdn.net/article/details/51055813">https://shiyi.blog.csdn.net/article/details/51055813</a></p><p><a href="https://github.com/shiyicode/project/blob/master/readme-images/20160404104940464.png"><img src="https://github.com/shiyicode/project/raw/master/readme-images/20160404104940464.png" alt="img"></a></p><h2 id="C-QT贪吃蛇"><a href="#C-QT贪吃蛇" class="headerlink" title="C++/QT贪吃蛇"></a>C++/QT贪吃蛇</h2><p>时间：2016-04</p><p>介绍：<a href="https://shiyi.blog.csdn.net/article/details/51058164">https://shiyi.blog.csdn.net/article/details/51058164</a></p><p><a href="https://github.com/shiyicode/project/blob/master/readme-images/20160404183256409.png"><img src="https://github.com/shiyicode/project/raw/master/readme-images/20160404183256409.png" alt="img"></a></p><h2 id="五子棋AI图形界面人机对战（JAVA实现）"><a href="#五子棋AI图形界面人机对战（JAVA实现）" class="headerlink" title="五子棋AI图形界面人机对战（JAVA实现）"></a>五子棋AI图形界面人机对战（JAVA实现）</h2><p>时间：2016-03</p><p>介绍：<a href="https://shiyi.blog.csdn.net/article/details/50913168">https://shiyi.blog.csdn.net/article/details/50913168</a></p><p><a href="https://github.com/shiyicode/project/blob/master/readme-images/20160317135042608.png"><img src="https://github.com/shiyicode/project/raw/master/readme-images/20160317135042608.png" alt="img"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++、项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project_list</title>
      <link href="/2021/09/22/taskLists/"/>
      <url>/2021/09/22/taskLists/</url>
      
        <content type="html"><![CDATA[<h1 id="项目清单"><a href="#项目清单" class="headerlink" title="项目清单"></a>项目清单</h1><p>这个列表原本来自伯乐在线的一篇<a href="http://blog.importnew.com/49762/">译文</a>。计划打算逐步实现清单中的项目。</p><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><ul><li>  逆转字符串——输入一个字符串，将其逆转并输出。</li><li>  拉丁猪文字游戏——这是一个英语语言游戏。基本规则是将一个英语单词的第一个辅音音素的字母移动到词尾并且加上后缀-ay（譬如“banana”会变成“anana-bay”）。可以在维基百科上了解更多内容。</li><li>  统计元音字母——输入一个字符串，统计处其中元音字母的数量。更复杂点的话统计出每个元音字母的数量。</li></ul><span id="more"></span><ul><li>  判断是否为回文——判断用户输入的字符串是否为回文。回文是指正反拼写形式都是一样的词，譬如“racecar”。</li><li>  统计字符串中的单词数目——统计字符串中单词的数目，更复杂的话从一个文本中读出字符串并生成单词数目统计结果。</li><li>  文本编辑器——记事本类型的应用，可以打开、编辑、保存文本文档。可以增加单词高亮和其它的一些特性。</li><li>  RSS源创建器——可以从其它来源读取文本并将其以RSS或者Atom的格式发布出去。</li><li>  实时股价——可以查询股票当前价格。用户可以设定数据刷新频率，程序会用绿色和红色的箭头表示股价走势。</li><li>  访客留言簿/日志——允许人们添加评论或者日记，可以设置开启/关闭评论，并且可以记录下每一条目的时间。也可以做成喊话器。</li><li>  新闻和比分播报器——一个桌面应用，可以从网上收集新闻和比赛分数，将结果在屏幕上滚动播出。</li><li>  占星罗盘——用占星术来预测每天的运程。</li><li>  密码短信——可以将数据加密解密，并能将其发送给朋友。</li><li>  帮你挑礼物——输入一堆你可能会送的礼物，当有人过生日时，该程序会随机选择一样礼物。也可以加上一个额外功能，可以告知哪里可以弄到这个礼物。</li><li>  HTML生成器——将 TEXT 文档转换成HTML文件，对制作网页HTML文档很有用。</li><li>  CD-Key生成器——利用某种算法生成一个唯一的key。软件开发者可以用它来作为软件的激活器。</li><li>  正则表达式查询工具——用户可以输入一段文本，在另外的控件里输入一个正则表达式。运行以后会返回匹配的内容或者正则表达式中的错误。</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>  FTP工具——与远程网络服务器交互文件。</li><li>  原子钟校时——从网上同步原子钟时间。全世界有很多原子钟，可以把它们都列出来。</li><li>  聊天应用（IRC或者MSN风格的）——像IRC那样的聊天室软件或者MSN那样的实时聊天软件。更复杂一点的话，可以为聊天制定一套你自己的传输协议。</li><li>  获取当前天气——获取某个地区当前的天气情况。</li><li>  P2P文件共享应用——像LimeWire、FrostWire、Bearshare或者torrent风格的应用。</li><li>  端口扫描器——输入某个ip地址和端口区间，程序会逐个尝试区间内的端口，如果能成功连接的话就将该端口标记为open。</li><li>  邮件检查工具（POP3/IMAP）——用户输入一些账号信息，包括服务器、ip、协议类型（POP3或者IMAP），应用每隔一段时间就会检查下该账号下的邮箱。</li><li>  数据包嗅探器——侦测电脑上进出的数据包，获取诸如目的地和大小之类的信息。</li><li>  IP注册地查询——输入ip地址，查询该ip是在哪注册的。</li><li>  Whois查询工具——输入一个ip或者主机地址，通过whois查询并将结果返回。</li><li>  邮编查询——输入邮编，返回使用该邮编的地区名称。</li><li>  远程登入——远程登入桌面类型的应用，可以查看和控制远程电脑（假如你已经获得权限）。可能需要你自己的网络和两台电脑来进行测试。</li><li>  网站定时检查器——每隔一段时间或者在预定的时间尝试连接某个网站或者服务器，来检查它是否可以连上，如果连不上了会通过邮件或者桌面通知来告知你。</li><li>  小型网页服务器——简易版的网页服务器，可以存放包含Javascript和其它形式代码的HTML文件。复杂一点的话可以尝试流媒体视频、创建一种服务器端语言或者其它类型的流媒体。</li><li>  网络蜘蛛——一个可以自动执行网页上各种任务的程序，任务包括网站检查、页面抓取、数据摘要以及网络邮务。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>  产品库存管理——创建一个管理产品库存的应用。建立一个产品类，包含价格、id、库存数量。然后建立一个库存类，记录各种产品并能计算库存的总价值。</li><li>  电影商店——管理录像带租借，记录借出时间、到期时间、逾期费用。复杂一点可以生成逾期用户的账号报告。</li><li>  航空/酒店预订系统——创建一套预订航班或酒店的预订系统。不同的航班座位和酒店房间收费不一样。譬如头等舱要比经济舱贵。带阁楼的套间要更贵些。记录下何时有空房可供预订。</li><li>  学生成绩管理器——记录一个班级的学生（创建一个Student类，记录他们的名字、平均分和考试分数）和他们的成绩等级。根据学生的测验和作业的分数计算出平均分和成绩等级。复杂一点可以将数据画在贝尔曲线上。</li><li>  银行账户管家——创建一个名为“Account”的抽象类，有三个为“CheckingAccount”、“SavingsAccount”和“BusinessAccount”的子类。通过类似ATM的程序来管理这些账户的借贷。</li><li>  馆藏目录——创建一个图书类，记录书名、页数、国际标准书号、是否借出。用它来管理各种书籍，允许用户进行借出和归还操作。复杂一点的话，可以生成逾期图书和逾期费用的报告。也可以让用户进行预约操作。</li></ul><h3 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h3><ul><li>  下载进度条——创建一个表示下载进度的进度条。进度条由独立的线程操作，通过委托来和主线程进行通讯。</li><li>  下载管理器——允许程序同时下载数个文件，每个都用单独的线程进行背景下载。主线程会关注下载进度并且在下载完成时通知用户。</li><li>  聊天软件（远程聊天）——做一个聊天软件，允许你通过ip直接连接到另一台电脑，也允许你的“服务器”程序处理多个请求连接。</li><li>  批量缩略图生成器——在进行图片转换的处理时会需要很多时间，尤其是图片很大时。做一个图片处理程序，能让你在做其它事的时候在后台线程里将数百张图片转换成某个大小的图片。复杂一点的话可以用一个线程来缩放，用另一个线程来为缩略图重命名。</li></ul><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><ul><li>  所见即所得编辑器——创建一个在线编辑器，允许用户移动元素、创建表格、书写文本、设置颜色，而用户不必懂HTML。就像Dreamweaver或者FrontPage。如果需要例子的话，可以参看DIC。</li><li>  分页浏览器——创建一个可以分页的小型网页浏览器，可以同时浏览几个网页。简化一点的话不要考虑Javascript或者其它客户端代码。</li><li>  文件下载器——该程序可以从网页上下载各种资源，包括视频和其它文件。用于有很多下载链接的网页。</li><li>  远程登录——创建一个远程登录的应用，可以通过网络登录服务器并能执行一些基本命令。</li><li>  在线白板——做一个在线白板程序，你和朋友们可以一起在白板上进行一些操作，画图、写字等等。</li><li>  带宽监视器——这个小工具可以记录你已经在网上上传和下载多少数据流量了。可以试着做份报告或者图表来展示各时段的使用情况。</li><li>  书签搜集管理器——该程序可以让用户上传书签并将它们排序，去掉重复的，并能生成书签文件以供Firefox/IE/Safari等使用。复杂一点的话可以试着将书签整理进不同的文件夹。</li><li>  密码保险箱——用来记录各种密码，并且将它们加密，这样别人就看不到了。</li><li>  iGoogle媒体播放器小部件——做一个iGoogle小部件，可以用来播放本地音乐列表，也可以每天分享一首歌。也许还可以让别人看到你最近听了些什么歌。</li><li>  基于文本的游戏——做一个像Utopia那样的文本RPG，游戏中，你可以创建一个文明、收集资源、共铸联盟、施放法术、回合制系统。看看是否能够统一王国。</li><li>  定时自动登录——做一个程序可以在预定的时间登录进某个指定的网页并且执行特定的动作，然后在登出。可以用来检查邮箱、发布常规内容、为其它程序获取信息。</li><li>  电子卡片生成器——可以让用户制作自己的电子卡片并发送给其他人。可以使用flash也可以不用。可以使用图片库，也可以加上深刻的格言警句。</li><li>  内容管理系统——像Joomala、Drupal、PHP Nuke这样的内容管理系统。从简单的做起，慢慢增加其它功能。</li><li>  模板制作器——该网站应用允许用户输入各种颜色代码、元素、尺寸，来为PHPBB、Invision Board、MySpace之类的应用创建模板文件。</li><li>  验证码生成器——应该在登录时见过有数字有字母的验证码图片吧？这可以防止自动登录和垃圾广告。试着自己做一个，如果使用PHP的话，看下GD的图片函数。</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>  试卷生成器——该程序可以从文件中随机挑选出不同的题目生成一份试卷。每份试卷可以不一样，通过读取答案来给打分。</li><li>  快速启动——该工具可以添加各个程序的小图标，点击小图标就可以运行程序。和Windows的快速启动类似。</li><li>  文件管理器——做一个文件管理器，要加些新特性，更佳的搜索功能、新图标、新外观。</li><li>  文件记录排序工具——从文件中读取记录，将其排序并写回文件中。允许用户选择排序风格以及排序关键字。</li><li>  生成财务交易文件并且算出平均值——将财务交易读进文件，按照账户分类、算出各项目的总量或平均值、理清各账户的借贷数据。</li><li>  Zip文件生成器——用户输入不同文件夹的文件，也许还包括其他电脑中的文件，然后程序将这些文件打包成zip文件。复杂一点的话，打包时对这些文件进行压缩。</li><li>  PDF生成器——从txt、html或其它文件中读取数据生成PDF文件。可以做成一个网页服务，用户上传文件，返回一个pdf版本。</li><li>  批量文件命名器——程序批量处理一些文件，将根据用户提供的过滤器为它们重命名。譬如用户输入的过滤器为myimage###.jpg，那么会生成至少包含3位数的文件名，譬如myimage001.jpg、myimage145.jpg，甚至是myimage1987.jpg，因为1987也满足了至少包含3位数的条件。</li><li>  MP3标签生成器——修改MP3文件的id3v1标签。还可以试着在MP3文件的头部加入id3v2的标签，譬如album art标签。</li><li>  日志文件生成器——该程序可以记录指定事件的日志。譬如程序做了什么、系统在干什么、文件什么时候被修改了。</li><li>  Excel分页输出器——做一个在线程序，可以读取文件内容生成一个excel分页。可以通过CVS或者其它文件格式来做。复杂一点的话看看是否能创建公式字段。</li><li>  RPG角色属性生成器——做一个程序来给RPG角色随机分配属性点数，可以由用户制定一些分配规则。可以生成职业、性别、力量/魔法/敏捷点数、额外能力或者贸易技能。把结果保存成文件，这样跑团的时候地下城主可以把它打印出来。</li><li>  文件复制工具——该工具可以批量处理文件复制和备份操作。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>  SQL查询分析器——该工具可以让用户输入一条查询命令，让其运行于本地数据库中。尽量让它运行得更高效。</li><li>  远程SQL工具——该工具能让你通过网络在远程服务器上执行查询操作。它能接收远程主机地址、验证用户名和密码、执行查询并返回结果。</li><li>  卡片整理器——创建一个在线应用，用来记录搜集到的卡片。可以让用户输入整套卡片，查看哪些已经有了，哪些还需要搜集。要增加复杂度的话，还可以让用户知道还差多少可以完成，或者已经收集卡片的价值。</li><li>  报告生成器——该工具可以根据数据库中的表格生成一份报告。譬如根据订单表格生成销售报告。</li><li>  数据库备份脚本制作器——该程序可以读取数据库的对象、关系、记录和步骤，生成一个sql文件，该文件可以导入另一个数据库或者作为备份文件。</li><li>  备忘录——该程序可以让用户设置一个日期和某个事件的时间、事件备注并将它们放到日历上。用户可以查看日历、搜索特定的事件。复杂一点的话，可以让用户设置重复发生的事件，譬如每天、每周、每月、每年等等。</li><li>  预算记录器——该程序可以记录家庭预算。用户可以添加支出、收入，计算一段时间内的收入和支出。复杂一点的话，让用户指定一个时间段，显示该时间段内的家庭收支情况。</li><li>  电话簿——记录各种联系人和他们的号码、邮箱、备注。复杂一点的话可以让用户连上网将电话簿发布到设置好的网站上。</li><li>  电视节目记录器——你是否有不想错过的电视节目？但没有录像机或者想之后能找到该电视节目然后录下来，那么可以做个程序寻找各种在线电视导航网站，记录下电视节目名称、播放时间、播放频道，存在数据库中。数据库或者网站到时就会发邮件提醒你，节目就快在某个频道开始了。</li><li>  旅行计划系统——该系统可以让用户管理旅行路线，记录下航班和酒店安排、感兴趣的地方、预算和时间表。</li><li>  实体关系图生成器——该程序可以让用户整合实体关系图，并将其保存起来，也可以用它来生成一些基础SQL语句。</li><li>  数据库翻译器（MySQL&lt;-&gt;SQL Server）——该工具可以从数据库A读取数据，生成数据库B使用的SQL语句，将数据存入数据库B。比较常用的是SQL Server和Oracle使用的MySQL服务器。</li><li>  BBS论坛——为你和小伙伴们做一个论坛，可以发帖、管理、分享想法和构思。</li></ul><h3 id="图像和多媒体"><a href="#图像和多媒体" class="headerlink" title="图像和多媒体"></a>图像和多媒体</h3><ul><li>  幻灯片——做一个以幻灯片形式显示各种图片的程序。为了增加难度可以做些额外的效果，譬如渐进检出、星型擦除、窗口渐隐。</li><li>  思维导图——允许用户记录下各种构思并且快速地进行头脑风暴将这些构思整合到一张思维导图中。越快越好，因此要让用户能迅速地写下构思，然后将其拖到可视的导图中去，将构思之间的关系展现出来。</li><li>  导入图片并存成灰度图——该工具将图片上的彩色除尽并保存。可以增加对比度调整、色化等额外功能以增加复杂度。</li><li>  在线流媒体视频——试着自己做一个在线流媒体视频播放器。</li><li>  MP3播放器（以及其他格式的音乐播放器）——该小程序用来播放你最爱的音乐文件。复杂一点的话看看能否加个播放列表功能和均衡器。</li><li>  批量图片处理——该程序可以将一个文件夹内的图片进行统一的处理，譬如降低图片色调、转换格式或者修改文件属性。还可以尝试给图片增加标签。</li><li>  CD烧录器——可以轻松烧录CD的工具。</li><li>  YouTube下载器——可以从Youtube.com上下载视频到硬盘中，要支持包括FLV和AVI在内的文件格式。</li><li>  墙纸管理工具——做一个管理墙纸的程序，可以定时更换刷新墙纸，也可以针对分辨率进行缩放。</li><li>  截屏程序——做一个可以截屏的工具，复杂一点可以增加一个转发邮件的功能。</li><li>  图片浏览器——该程序可以查看电脑上各种格式的图片，譬如PNG、GIF、JPG、BMP、TIFF等等。</li><li>  交通信号灯——试着做一个交通信号灯并且把它放到可以互动的场景中。不要让汽车闯红灯或者撞到其它车。</li><li>  MP3-WAV转换器——MP3格式本质上就是压缩版的WAV。试着将MP3转换成WAV格式以供可以处理WAV格式的程序使用。请记住1MB的MP3大约等于10MB的WAV。</li><li>  签名生成器——是否在网上见过有人的留言后面有条生成的签名？试着做个程序让用户可以指定背景、文字、颜色和对齐方式来定制一个签名档。</li><li>  屏保——电脑空闲时会运行的屏保程序。简单版的可以使用一些标准图片，复杂版的可以做出能在屏幕上转来转去的3D物体。</li><li>  水印——你是否想保护你图片的版权？在图片上加上标志或者文字，这样别人就不能轻易地从你网站上盗图了。做一个程序来给你的图片加上水印吧。</li><li>  海龟图——创建一个20*20的格子，用命令让一只海龟在格子上画线。可以前进、左转、右转，拿起或放下笔等等。复杂一点的话，允许程序从文件中读取命令列表。可以在网上了解到更多关于“海龟图”的信息。</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li>  战船——创建两块游戏面板，玩家各占一边，在上面放置一些战船，玩家看不到对方的面板。每艘船都占几个格子，玩家轮流攻击某个格子，如果格子上有船，那就命中目标，否则就是未命中。当一艘船所占的所有格子都被攻击命中了，那么船就被击沉。谁先将对方战船全部击沉就获胜。</li><li>  象棋跳棋——象棋或者跳棋游戏。可以试着做成可以联网玩，用图形用户界面来实现悔棋、保存走棋过程并且可以回放。</li><li>  刽子手——从文件中随机选择一个单词，让玩家猜单词中的字母。旁边是一幅隐藏的行绞刑的画，猜错一个单词，画就显示出一部分。画全部显示出来时还没能猜全的话玩家就输了。</li><li>  填字游戏——创建一个填字游戏，并为每个词提供一个提示信息，让玩家填上所有正确的单词。</li><li>  青蛙跳——让青蛙跳过河或者马路，过河的话要跳在顺流而下速度各异的木头或者睡莲叶子上，过马路的话要避开速度各异的车子。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
